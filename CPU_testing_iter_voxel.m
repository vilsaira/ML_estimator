function [theta, sigmasq, iter_voxel, iter_theta, iter_S0, iter_loglikelihood] =...
    CPU_testing_iter_voxel(theta, sigmasq, Z, Y, nParams,...
                           sumYsquare1, nDWIs,...
                           iter_sigmasq, iter_limit_sigmasq, tolerance_sigmasq,...
                           iter_voxel, iter_limit_voxel, tolerance_voxel,...
                           iter_theta, iter_limit_theta, tolerance_theta,...
                           iter_S0, iter_limit_S0, tolerance_S0,...
                           iter_loglikelihood, iter_limit_loglikelihood,...
                           tolerance_loglikelihood, nVoxel)
zSlice = Z;
Y1 = Y;
go_voxel = true;
iter_voxel = 0;          
while go_voxel

    theta0 = theta;
    sigmasq0 = sigmasq;
    iter_voxel = iter_voxel + 1;    
    % Second, optimize w.r.t. theta(1) with fixed theta(2:end) and sigmasq
    expZtheta = exp( zSlice( : , 2 : end ) * theta( 2 : end ) );
    a = log( expZtheta' * expZtheta );
    b = Y1 .* expZtheta;
    twotau = b * exp( theta( 1 ) ) / sigmasq;

    S0 = theta(1);
    [theta(1), iter_S0, twotau] = CPU_testing_iter_voxel_S0(...
        S0, sigmasq, a, b, twotau, 0, iter_limit_S0, tolerance_S0);
%     if (theta(1) <= 0.0)
%         disp(['negative theta1 at slice/voxel ', num2str(nSlice), ' / ', num2str(nVoxel)]);
%     end
    % Third, optimize the Rice likelihood w.r.t theta( 2 : end ) for
    % fixed theta( 1 ) and sigmasq

    EN = 0.5 * ( twotau .* cpu_besseli( 1, twotau ) ./ ...
        cpu_besseli( 0, twotau ) );
              
    
    if any( EN > 0.0 )      
        [theta, I, iter_theta, iter_loglikelihood] = ...
            CPU_testing_iter_voxel_theta(theta, sigmasq, EN, zSlice, nParams,...
                           iter_theta, iter_limit_theta, tolerance_theta,...
                           iter_loglikelihood, iter_limit_loglikelihood,...
                           tolerance_loglikelihood);
    else
        % There's no information about the tensor
        theta( 2 : end ) = 0.0;
        I = zeros( nParams - 1, nParams - 1);
    end

    % Fourth, optimize again w.r.t sigmasq with fixed theta
    expZtheta = exp( zSlice * theta );            
    a = ( sumYsquare1 + ...
                expZtheta'*expZtheta ); 
    b = Y1 .* expZtheta;            

    [sigmasq, iter_sigmasq] = CPU_testing_iter_sigmasq(...
    sigmasq, a, b, iter_sigmasq, iter_limit_sigmasq, tolerance_sigmasq, nDWIs);

    % Test if convergence is reached
    
    go_voxel = (...
               ( abs((sigmasq-sigmasq0)/sigmasq0) > tolerance_voxel ) ...
               || ...
               ( norm(theta-theta0)/norm(theta0) > tolerance_voxel ) ...
               )...
               && ...
               ( iter_voxel < iter_limit_voxel );

end


end