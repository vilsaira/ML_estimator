function [theta, I, iter_theta, iter_loglikelihood] = ...
    CPU_testing_iter_voxel_theta(theta, sigmasq, EN, zSlice, nParams,...
                           iter_theta, iter_limit_theta, tolerance_theta,...
                           iter_loglikelihood, iter_limit_loglikelihood,...
                           tolerance_loglikelihood)

c = 2.0 * theta(1) - log(2.0 * sigmasq);                
ZZ = 2.0 * zSlice(:, 2:end);                
Ztheta = ZZ * theta(2:end) + c;
scaling = max(Ztheta);
expo = exp(Ztheta - scaling);
exp_scaling = exp(scaling);
loglikelihood = EN' * Ztheta - sum(expo) * exp_scaling;

iter_theta = 0;
go_theta = true;

% compare to glmfitPoisson3Ridge.m 
loglikelihood0 = loglikelihood;
while go_theta      
    iter_theta = iter_theta + 1;
    score = ZZ' * ( EN - expo * exp_scaling );
    
    I = ( ZZ' * diag( expo ) * ZZ );
    I = ( I + I' ) * ( 0.5 * exp_scaling ); % symmetrize 

    [theta, new_theta, DeltaTheta, loglikelihood, loglikelihood0, expo, exp_scaling, iter_loglikelihood] =...
        CPU_testing_iter_voxel_theta_loglikelihood(...
                              theta, I, score, nParams, EN, Ztheta, ZZ, c, expo,...
                              exp_scaling, loglikelihood, loglikelihood0,...
                              iter_loglikelihood, iter_limit_loglikelihood,...
                              tolerance_loglikelihood);
    
    go_theta = (...
               ( DeltaTheta' * score > tolerance_theta ) ...
               || ...
               ( loglikelihood - loglikelihood0 > tolerance_loglikelihood ) ...
               )...
               && ...
               ( iter_theta < iter_limit_theta );
    
   loglikelihood0 = loglikelihood;
   theta(2:end) = new_theta;
end


end